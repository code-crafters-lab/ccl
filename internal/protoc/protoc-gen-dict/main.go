package main

import (
	"bytes"
	"flag"
	"fmt"
	"math"
	"os"
	"strings"
	"unicode"

	"connectrpc.com/connect"
	"github.com/code-crafters-lab/ccl/internal/gen/extension"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

const (
	name       = "dict"
	pluginName = "protoc-gen-" + name
	version    = "0.1.0"
	noteSymbol = "// "

	generatedFilenameExtension = ".dict.go.txt"
	usage                      = "See https://connectrpc.com/docs/go/getting-started to learn how to use this plugin.\n\nFlags:\n  -h, --help\tPrint this help and exit.\n      --version\tPrint the version and exit."
)

func main() {
	if len(os.Args) == 2 && os.Args[1] == "--version" {
		_, _ = fmt.Fprintln(os.Stdout, connect.Version)
		os.Exit(0)
	}
	if len(os.Args) == 2 && (os.Args[1] == "-h" || os.Args[1] == "--help") {
		_, _ = fmt.Fprintln(os.Stdout, usage)
		os.Exit(0)
	}
	if len(os.Args) != 1 {
		_, _ = fmt.Fprintln(os.Stderr, usage)
		os.Exit(1)
	}
	var flagSet flag.FlagSet
	//packageSuffix := flagSet.String(
	//	packageSuffixFlagName,
	//	defaultPackageSuffix,
	//	"Generate files into a sub-package of the package containing the base .pb.go files using the given suffix. An empty suffix denotes to generate into the same package as the base pb.go files.",
	//)
	//// "simple" is a bool, but we want to support just setting "simple" without needing to set "simple=true"
	//// We do this via making the flag a string, and then parsing manually in getSimpleBool.
	//simpleString := flagSet.String(
	//	simpleFlagName,
	//	"false",
	//	"Generate client and handler interfaces with simple function signatures. This eliminates the wrapper connect.Request and connect.Response types, instead having functions directly use generated RPC request and responses. Clients and handlers will instead use context.Contexts to propagate information such as headers. Most users will be more familiar with these interfaces than the default.",
	//)
	protogen.Options{
		ParamFunc: flagSet.Set,
	}.Run(
		func(plugin *protogen.Plugin) error {
			plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL) | uint64(pluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS)
			plugin.SupportedEditionsMinimum = descriptorpb.Edition_EDITION_PROTO2
			plugin.SupportedEditionsMaximum = descriptorpb.Edition_EDITION_2024
			for _, file := range plugin.Files {
				if file.Generate {
					generate(plugin, file)
				}
			}
			return nil
		},
	)
}

func generate(plugin *protogen.Plugin, file *protogen.File) {
	if len(file.Enums) == 0 {
		return
	}

	filename := file.GeneratedFilenamePrefix + generatedFilenameExtension
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	generatePreamble(g, file, protocVersion(plugin))

	dictionaries := make([]*dict, 0)
	for _, enum := range file.Enums {
		dictionaries = append(dictionaries, ofDict(enum.Desc))
	}

	//_, _ = fmt.Fprintln(os.Stdout, dictionaries)d
	buf := bytes.Buffer{}

	for i, d := range dictionaries {
		buf.WriteString(fmt.Sprintf("dictionaries[%d] = %d,%s,%s,%s\n", i, d.ID, d.Code, d.FullCode, d.Name))
		for _, item := range d.Items {
			buf.WriteString(fmt.Sprintf("%d,%s,%d,%s,%d,%s\n", item.ID, item.Code, item.Value, item.Name, item.Sort, item.Description))
		}
	}

	_, _ = g.Write(buf.Bytes())
}

func protocVersion(plugin *protogen.Plugin) string {
	v := plugin.Request.GetCompilerVersion()
	if v == nil {
		return ""
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

func generatePreamble(g *protogen.GeneratedFile, file *protogen.File, protocVersion string) {
	g.P(noteSymbol, "Code generated by ", pluginName, ". DO NOT EDIT!")
	g.P(noteSymbol, "versions:")
	l := int(math.Max(float64(len(pluginName)), 6))
	g.P(noteSymbol, fmt.Sprintf("- %-*s \tv%s", l, pluginName, version))
	if protocVersion != "" {
		g.P(noteSymbol, fmt.Sprintf("- %-*s \tv%s", l, "protoc", protocVersion))
	}
	if file.Proto.GetOptions().GetDeprecated() {
		g.P(noteSymbol, file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P(noteSymbol, "source: ", file.Desc.Path())
	}
	g.P()
}

type dict struct {
	ID          int64       `json:"id"`
	Code        string      `json:"code"`
	FullCode    string      `json:"full_code"`
	Name        string      `json:"name"`
	Description string      `json:"description"`
	Items       []*dictItem `json:"items"`
}

type dictItem struct {
	ID          int64  `json:"id"`
	Code        string `json:"code"`
	Value       int    `json:"value"`
	Name        string `json:"name"`
	Sort        int    `json:"sort"`
	Description string `json:"description"`
}

func ofDict(enumDesc protoreflect.EnumDescriptor) *dict {
	d := dict{
		Code:     string(enumDesc.Name()),
		FullCode: string(enumDesc.FullName()),
	}
	// 2. 读取 enum 级别（EnumOptions）的扩展
	enumOptions := enumDesc.Options()
	// 是否忽略枚举领值
	ignoreZero := true
	if proto.HasExtension(enumOptions, extension.E_Dict) {
		ext := proto.GetExtension(enumOptions, extension.E_Dict)
		metadata := ext.(*extension.EnumMetadata)
		if metadata.Name != nil {
			d.Name = *metadata.Name
		}
		if metadata.Description != nil {
			d.Description = *metadata.Description
		}
	}
	// 字典唯一 id 生成
	d.ID = int64(enumDesc.Index())
	//  字典项数据
	d.Items = ofDictItems(enumDesc, ignoreZero)
	return &d
}

func ofDictItems(enumDesc protoreflect.EnumDescriptor, ignoreZero bool) []*dictItem {
	valueDescriptors := enumDesc.Values()
	items := make([]*dictItem, 0)

	for j := range valueDescriptors.Len() {
		enumValueDesc := valueDescriptors.Get(j)
		if ignoreZero && enumValueDesc.Number() == 0 {
			continue
		}

		item := &dictItem{
			Code:  replaceEnumPrefix(string(enumValueDesc.Name()), enumDesc.Name()),
			Value: int(enumValueDesc.Number()),
			Sort:  enumValueDesc.Index(),
		}

		enumValueOptions := enumValueDesc.Options()
		options := enumValueOptions.(*descriptorpb.EnumValueOptions)
		deprecated := options.Deprecated != nil && *options.Deprecated
		if deprecated {
			item.Description = "已废弃"
		}
		if proto.HasExtension(enumValueOptions, extension.E_Item) {
			valExt := proto.GetExtension(enumValueOptions, extension.E_Item)
			itemMetadata := valExt.(*extension.EnumMetadata)
			if deprecated && itemMetadata.ReplaceWith != nil {
				item.Description += " (请使用 " + replaceEnumPrefix(*itemMetadata.ReplaceWith, enumDesc.Name()) + " 代替)"
			}
			if itemMetadata.Name != nil {
				item.Name = *itemMetadata.Name
			}
			if itemMetadata.Description != nil {
				description := item.Description
				if description != "" {
					item.Description += ";" + *itemMetadata.Description
				} else {
					item.Description = *itemMetadata.Description
				}
			}
		}

		items = append(items, item)

	}
	return items
}

func replaceEnumPrefix(code string, name protoreflect.Name) string {
	prefix := CamelToSnakeUpper(string(name))
	return strings.TrimLeft(strings.Replace(code, prefix, "", 1), "_")
}

// CamelToSnakeUpper converts a CamelCase string to SNAKE_CASE_UPPER.
func CamelToSnakeUpper(s string) string {
	if s == "" {
		return ""
	}

	var builder strings.Builder
	// 预留足够的容量，避免多次内存分配
	builder.Grow(len(s) + 4) // 预估最多会增加4个下划线

	for i, r := range s {
		// 如果是大写字母，并且满足以下条件之一，则在前面添加下划线：
		// 1. 不是第一个字符。
		// 2. 前一个字符不是下划线。
		// 3. 后一个字符是小写字母（处理 "HTTPRequest" -> "HTTP_REQUEST" 的情况）。
		// 4. 前一个字符是小写字母（处理 "MyID" -> "MY_ID" 的情况）。
		if unicode.IsUpper(r) {
			if i > 0 && s[i-1] != '_' &&
				((i+1 < len(s) && unicode.IsLower(rune(s[i+1]))) || unicode.IsLower(rune(s[i-1]))) {
				builder.WriteRune('_')
			}
		}
		builder.WriteRune(r)
	}

	return strings.ToUpper(builder.String())
}
